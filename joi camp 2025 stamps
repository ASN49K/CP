#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using i64 = long long;
#define int long long
#define all(x) x.begin(),x.end()
//nr de perechi care NU se intersecteaza
const i64 INF=3e18;

struct aib
{
    i64 total=0;
    int n;
    std::vector<i64>a;
    int lsb(int x)
    {
        return x&(-x);
    }
    aib(){}
    aib(int n)
    {
        a.assign(n+1,0);
        this->n=n;
    }
    void update(int poz,int val)
    {
        total+=val;
        for(int i=poz;i<=n;i+=lsb(i))
        {
            a[i]+=val;
        }
    }
    i64 query_prefix(int poz)
    {
        i64 rez=0;
        for(int i=poz;i>0;i-=lsb(i))
        {
            rez+=a[i];
        }
        return rez;
    }
    i64 query_suffix(int poz)
    {
        return total-query_prefix(poz-1);
    }
};

int n;
namespace intervale
{
    i64 rez;
    aib left_points,right_points;
    void init()
    {
        left_points=right_points=aib(4*n);
    }
    void add(int l,int r,int sign)
    {
        if(sign==-1)
        {
            left_points.update(l,sign);
            right_points.update(r,sign);
        }

        rez+=sign*right_points.query_prefix(l);
        rez+=sign*left_points.query_suffix(r);

        if(sign==1)
        {
            left_points.update(l,sign);
            right_points.update(r,sign);
        }
    }
    i64 query()
    {
        return rez;
    }
}
main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int x;
    std::cin>>n>>x;
    intervale::init();
    std::vector<int>a(2*n);
    std::vector<i64>perechi_from_poz(2*n),cost(2*n);
    std::vector<int>hashed_pair(n);
    for(int i=0;i<2*n;i++)
    {
        int x;
        std::cin>>x;
        x--;
        if(hashed_pair[x]!=0)
        {
            intervale::add(hashed_pair[x],i+1,1);
        }
        hashed_pair[x]^=(i+1);
        a[i]=x;
    }
    for(int i=0;i<2*n;i++)
    {
        hashed_pair[a[i]]^=(i+1);
        int other=hashed_pair[a[i]];
        hashed_pair[a[i]]^=(2*n+i+1);
        perechi_from_poz[i]=intervale::query();


        intervale::add(i+1,other,-1);
        intervale::add(other,2*n+i+1,1);
    }


    for(auto &c:cost)
    {
        std::cin>>c;
    }


    //prefix si suffix
    std::map<i64,std::pair<i64,i64>>mp;

    for(int i=0;i<2*n;i++)
    {
        mp[perechi_from_poz[i]]={INF,INF};
    }
    for(int i=0;i<2*n;i++)
    {
        mp[perechi_from_poz[i]].first=std::min(mp[perechi_from_poz[i]].first , cost[i]);
        mp[perechi_from_poz[i]].second=std::min(mp[perechi_from_poz[i]].second , cost[i]+perechi_from_poz[i]*x);
    }
    i64 last=INF;
    for(auto it=mp.begin();it!=mp.end();it++)
    {
        it->second.first=std::min(last,it->second.first);
        last=std::min(last,it->second.first);
    }
    //fac o tehnica
    last=INF;
    for(auto it=mp.end();it!=mp.begin();)
    {
        it=prev(it);
        it->second.second=std::min(last,it->second.second);
        last=std::min(last,it->second.second);
    }

    int q;
    std::cin>>q;
    while(q--)
    {
        i64 k;
        std::cin>>k;
        k=1LL*n*n-k;
        i64 sol=INF;
        auto it=mp.upper_bound(k);
        if(it!=mp.end())
        {
            sol=std::min(sol , it->second.second-k*x);
        }
        if(it!=mp.begin())
        {
            it=prev(it);
            sol=std::min(sol , it->second.first);
        }

        std::cout<<sol<<'\n';
    }
}
