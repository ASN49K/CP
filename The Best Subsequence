#include <bits/stdc++.h>
using i64=long long;
#define UNUSED -1
#define all(x) x.begin(),x.end()
#define pb push_back
const int inf=2e9;
const i64 INF=1e18;
const int mod=1e9+7;
int add(int x,int y)
{
    x+=y;
    if(x>=mod)
    {
        x-=mod;
    }
    if(x<0)
    {
        x+=mod;
    }
    return x;
}
void add_self(int& x,int y)
{
    x=add(x , y);
}
int prod(int x,int y)
{
    return (1LL*x*y)%mod;
}
int pw2(int a,int p)
{
    int rez=1;
    while(p>0)
    {
        if(p&1)
        {
            rez=prod(rez , a);
        }
        a=prod(a,a);
        p/=2;
    }
    return rez;
}
int n,m,q;
std::vector<std::pair<int,int>>segments;
std::vector<std::array<int,3>>querys;

struct position_values
{
    int first_pos,nr_1_now,nr_1_total,hash;
};
//[l,r] daca ar fi pline de 1
int hash_segment(int l,int r)
{
    r++;
    //std::cout<<l<<' '<<r<<'\n';
    return add(pw2(2,n-l+1),-pw2(2,n-r+1));
}
int invers(int x)
{
    return pw2(x,mod-2);
}

namespace solve_normal
{
    std::vector<position_values>a;

    //segmentul care il cuprinde pe pos_finish
    int bs_smaller_equal(int pos_finish)
    {
        int st=0,dr=a.size()-1;
        int rez=-inf;
        while(st<=dr)
        {
            int mid=(st+dr)/2;
            if(a[mid].first_pos<=pos_finish)
            {
                st=mid+1;
                rez=mid;
            }
            else
            {
                dr=mid-1;
            }
        }
        if(rez==-inf)
        {
            exit(0);
        }
        return rez;
    }
    //nr de 1 in intervalul [1,pos_finish]
    int count_1_prefix(int pos_finish)
    {
        int it=bs_smaller_equal(pos_finish);
        if(it==0)
        {
            return 0;
        }
        return a[it-1].nr_1_total+std::min(pos_finish-a[it].first_pos+1,a[it].nr_1_now);
    }
    int get_count_1(int l,int r)
    {
        return count_1_prefix(r)-count_1_prefix(l-1);
    }

    int hash_prefix(int pos_finish)
    {
        int it=bs_smaller_equal(pos_finish);
        if(it==0)
        {
            return 0;
        }
        return a[it-1].hash+hash_segment(a[it].first_pos , std::min(a[it].first_pos+a[it].nr_1_now-1,pos_finish));
    }

    int get_hash(int l,int r)
    {
        return hash_prefix(r)-hash_prefix(l-1);
    }
    std::vector<int> solve()
    {
        std::map<int,int>mp;
        for(auto &c:segments)
        {
            mp[c.first]++;
            mp[c.second+1]--;
        }
        int sum=0;
        int last=1;
        a.clear();
        a.push_back({-inf,0,0});

        for(auto &c:mp)
        {
            int last_sum=sum;
            sum+=c.second;
            if(sum%2==1 && last_sum%2==0)
            {
                last=c.first;
            }
            if(sum%2==0 && last_sum%2==1)
            {
                a.push_back({last , c.first-last , a.back().nr_1_total+c.first-last , add(a.back().hash, hash_segment(last,c.first-1))});
            }
        }
        a.push_back({inf,0,0,0});
        std::vector<int>rez(q);
        for(int i=0;i<q;i++)
        {
            int l=querys[i][0];
            int r=querys[i][1];
            int k=querys[i][2];

            int all_1=get_count_1(l,r);
            if(all_1>=k)
            {
                rez[i]=add(pw2(2,k) , -1);
            }
            else
            {
                int st=l,dr=r,rez_bs=-1;
                while(st<=dr)
                {
                    int mid=(st+dr)/2;
                    if(k-all_1==r-mid+1-get_count_1(mid,r))
                    {
                        rez_bs=mid;
                        break;
                    }
                    else if(k-all_1<r-mid+1-get_count_1(mid,r))//partea din dr e nr de 0 din intervalul [mid,r]
                    {
                        st=mid+1;
                    }
                    else
                    {
                        dr=mid-1;
                    }
                }
                if(rez_bs==-1)
                {
                    exit(0);
                }
                int cnt__1=get_count_1(rez_bs,r);
                int left_part=add(pw2(2,k),-pw2(2,(r-rez_bs+1)));
                int right_part=prod(get_hash(rez_bs,r) , invers(pw2(2,n-r)));
                rez[i]=add(left_part , right_part);
            }
        }

        return rez;
    }
}

void read_and_solve()
{
    std::cin>>n>>m>>q;
    segments.resize(m);
    querys.resize(q);
    for(auto &c:segments)
    {
        std::cin>>c.first>>c.second;
    }
    for(auto &c:querys)
    {
        std::cin>>c[0]>>c[1]>>c[2];
    }
    auto v=solve_normal::solve();
    for(auto &c:v)
    {
        std::cout<<c<<'\n';
    }
    exit(0);
}


std::mt19937 rng(69);
int range(int l,int r)
{
    return l+(rng()%(r-l+1));
}
signed main()
{
    read_and_solve();
    while(true)
    {
        n=range(1,10);
        m=range(1,2);
        q=1;
        segments.assign(m,{0,0});
        querys.assign(q,{0,0,0});
        for(auto &c:segments)
        {
            c.first=range(1,n);
            c.second=range(c.first,n);
        }
        for(auto &c:querys)
        {
            c[0]=range(1,n);
            c[1]=range(c[0],n);
            c[2]=range(1,c[1]-c[0]+1);
        }
        solve_normal::solve();
    }
    return 0;
}
/*
4 2 1
3 4
1 4
4 4 1
*/
