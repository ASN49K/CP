template<typename T>
struct binary_node
{
    binary_node *l,*r;
    T val;
    binary_node(T x)
    {
        l=r=nullptr;
        val=x;
    }
};
template<typename T>
void clear(binary_node<T>*&X)
{
    if(X==nullptr)
        return;
    clear(X->l);
    clear(X->r);
    delete X;
}

typedef binary_node<int> node;
int value(node *&X)
{
    if(X==nullptr)
        return 0;
    return X->val;
}
class aint_implicit
{
    int n;
    node* root=nullptr;
    int add(node *&X,const int st,const int dr,const int& poz)
    {
        if(poz<st || poz>dr)
        {
            return value(X);
        }
        if(X==nullptr)
        {
            X=new node(0);
        }
        X->val++;
        if(st!=dr)
        {
            int m=(st+dr)/2;
            add(X->l,st,m,poz);
            add(X->r,m+1,dr,poz);
        }
    }

    int query(node *&X,const int st,const int dr,const int& l,const int& r)
    {
        if(l>dr || r<st)
            return 0;
        if(l<=st && dr<=r || X==nullptr)
            return value(X);
        int m=(st+dr)/2;
        return query(X->l,st,m,l,r)+query(X->r,m+1,dr,l,r);
    }

public:
    void init(int sz)
    {
        n=sz;
        clear(root);
        root=nullptr;
    }
    void add(int poz)
    {
        add(root,1,n,poz);
    }
    int query(int l,int r)
    {
        return query(root,1,n,l,r);
    }
    int query(int l)
    {
        if(l>n)
            return 0;
        return query(root,1,n,l,n);
    }
    ~aint_implicit()
    {
        clear(root);
    }
};
